"""
reconstruct the video file and overwrite parts of the scored txt file
delete useless frames in the video file, only save the frames contain reaches

no worry about the potential damage caused by running multiple times in the same folder,
it will automatically detect whether it is processed.

no input

written by Frank
1/18/2019
(get the card from the secretary office, but it doesn't work
sad T_T)
"""

import cv2
import os
from tqdm import tqdm
import fileinput
import sys


def getFilePairList():
    '''
    find all the scored txt files and the video files related to them
    :return:
    two lists containing txt directories and video directories respectively
    '''
    print ("Loooooking for the potential files used for training")
    relevantDir = "../../AnimalProfiles"
    absDir = os.path.abspath(relevantDir)
    list_1 = os.listdir(absDir)
    txtFileList = []
    videoFileList = []
    for directory in tqdm(list_1):
        list_2 = os.listdir(os.path.join(absDir, directory,'Analyses'))
        for directory_2 in list_2:
            list_3 = os.listdir(os.path.join(absDir, directory,'Analyses', directory_2))
            for file in list_3:
                if file.count('reaches_scored.txt'):
                    txtFile = os.path.join(absDir, directory, 'Analyses', directory_2, file)
                    videoFile = os.path.join(absDir, directory, 'Analyses',directory_2, directory_2 + '.avi')
                    if os.path.exists(videoFile) and os.path.exists(txtFile):
                        txtFileList.append(txtFile)
                        videoFileList.append(videoFile)
    return txtFileList, videoFileList


def findLabelinTxt(txtFile):
    '''
    :param txtFile: a file name of scored txt file you want to process
    :return: a list containing the start frame and the end frame
    and it will also replace the old ones by new indexes of frames
    '''
    i = 0
    dataList = []
    data = []
    with open(txtFile, 'r') as f:
        lines = f.readlines()
    for line in lines:

        line = line.replace('\n', '')

        listLine = line.split(',')

        if len(listLine) == 1:

            i += 1
            try:
                num = int(listLine[0])
            except ValueError:
                num = -100

            if num >= 0:
                data.append(num)


        if i >= 5:
            if len(data) == 2:
                dataList.append(data)
            data = []
            i = 0
    pos = 0
    startFlag = True
    frame = -1

    for line in fileinput.input(txtFile, inplace=1):

        templine = line.replace('\n', '')

        listLine = templine.split(',')

        if len(listLine) == 1:

            i += 1
            try:
                num = int(listLine[0])
            except ValueError:
                num = -100

            if num >= 0 :
                if startFlag:
                    if pos == 0:
                        frame = 0
                    else:
                        frame += 1
                    startFlag = False
                else:
                    frame += (dataList[pos][1] - dataList[pos][0])
                    pos += 1
                    startFlag = True
                sys.stdout.write(str(frame) + '\n')
            else:
                sys.stdout.write(line)
        else:
            sys.stdout.write(line)

    return dataList


def getImagesInSequence(videoFile, dataList):
    '''
    it will pick up the frames of interest and stack them into one video
    :param videoFile: a filename of video
    :param dataList: a list generated by function findLabelinTxt
    :return: a list contains all the frames of interest
    '''
    cam = cv2.VideoCapture(videoFile)
    retVal = True
    videoLength = int(cam.get(cv2.CAP_PROP_FRAME_COUNT))
    print("video length: %d"%videoLength)
    i = 0
    video = []
    videoNum = 0
    startFrame = dataList[videoNum][0]
    endFrame = dataList[videoNum][1]

    while cam.isOpened() and retVal:

        retVal, inputImage = cam.read()

        if i > startFrame and i < endFrame:
            inputImage = cv2.cvtColor(inputImage, cv2.COLOR_RGB2GRAY)
            video.append(inputImage)

        elif i == endFrame:

            videoNum += 1
            if videoNum >= len(dataList):
                break
            startFrame = dataList[videoNum][0]
            endFrame = dataList[videoNum][1]
            print("start frame:%d, end frame: %d" % (startFrame, endFrame))

        i += 1
    cam.release()

    return video


def constructRawDataSet():
    '''
    The main enrtance of this script
    :return:
    '''
    txtFileList, videoFileList = getFilePairList()
    assert len(txtFileList) == len(videoFileList), 'Wrong with the files!'
    fourcc = cv2.VideoWriter_fourcc('X', 'V', 'I', 'D')
    count = 0
    for i in range(len(txtFileList)):
        print ("processing txtfile NO.%d, Name: %s"%(i, txtFileList[i]))
        saveDir = videoFileList[i]

        dataList = findLabelinTxt(txtFileList[i])
        if dataList[0][0] == 0:
            print("Has been processed txtfile NO.%d, Name: %s"%(i, txtFileList[i]))
            continue
        video = getImagesInSequence(videoFileList[i], dataList)
        cam = cv2.VideoWriter(saveDir, fourcc, 40.0, (video[0].shape[1], video[0].shape[0]), False)
        i = 0
        print("saving...")
        for frame in video:
            i += 1
            cam.write(frame)
        cam.release()

        count += 1

if __name__ == '__main__':
    constructRawDataSet()
